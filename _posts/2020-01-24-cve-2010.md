---
layout: single
title:  "Linux Kernel Vulnerability Root Causes CVE-2010-3873  "
date:   2020-01-24
toc: true
toc_label: Table
toc_sticky: true
classes: wide

---




It happens when the Kernel code perform incrroect integer operation which can lead to **integer overflow** or **under overflow**. In reality the most common issue with that , it will lead to allocate large size or access to incrroect index. 



## Case study Linux Kernel <= 2.6.9



integer overflow issue => Integer overflow affectt **Linux Kernel  2.6.9** 

```c
static int bluez_sock_create(struct socket *sock, int proto) {
if (proto >= BLUEZ_MAX_PROTO) return –EINVAL;
[...]
return bluez_proto[proto]->create(sock,proto);
}

```

the issue here is the proto against BLUEZ_MAX .. However the check it can bypass it using 0xffffffff for intsance :) 

to secure it add this check **proto < 0** or **unisgned in proto** 



here is my modify to secure it :)

```c
static int bluez_sock_create(struct socket *sock, int proto) {
if (proto < 0 || proto >= BLUEZ_MAX_PROTO) return –EINVAL;
[...]
return bluez_proto[proto]->create(sock,proto);

```




## Example 

I **created a simple integer overflow example** for secure and insecure **copy_to** function 

```c
#include <stdio.h>
#include <stdlib.h>
//Fahad
#define MAX_SIZE 10
//int copy_to(char *what , int max);

int copy_to(char *what, int max){ <= integer overflow
//int copy_to(char *what, unsigned int max){ // <= secure 
	char buf[10];
	if( max >= MAX_SIZE){
		return 0;
	}
	//memcpy(buf,what,0xffffffff);
	memcpy(buf,what,max);
	return 1;
}
int main(){
	copy_to("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",0xffffffff);
	
}
```





## case study CVE-2010-3873




```c
			switch (*p) {
 			case X25_FAC_CALLING_AE:
-				if (p[1] > X25_MAX_DTE_FACIL_LEN)
-					break;
+				if (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)
+					return 0;
 				dte_facs->calling_len = p[2];
 				
 				memcpy(dte_facs->calling_ae, &p[3], p[1] - 1);
 				*vc_fac_mask |= X25_MASK_CALLING_AE;
 				break;
 			case X25_FAC_CALLED_AE:
-				if (p[1] > X25_MAX_DTE_FACIL_LEN)
-					break;
+				if (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)
+					return 0;
 				dte_facs->called_len = p[2];
 				memcpy(dte_facs->called_ae, &p[3], p[1] - 1);
 				*vc_fac_mask |= X25_MASK_CALLED_AE;
```



the p array against x25_max .. but did not check if p index 1 less than **0** , therefore it will bypass bounds checking and it going to copy an extremely large amount of data when it reach to **memcpy** function.



**References** 

A Guide to kernel exploitation attacking the core 

https://github.com/mirror/dd-wrt/blob/master/src/linux/brcm/linux.v24/net/bluetooth/af_bluetooth.c

https://pdos.csail.mit.edu/papers/chen-kbugs.pdf

https://www.exploit-db.com/exploits/39505
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a6331d6f9a4298173b413cf99a40cc86a9d92c37

https://pdos.csail.mit.edu/papers/chen-kbugs.pdf
